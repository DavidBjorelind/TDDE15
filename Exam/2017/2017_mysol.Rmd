---
title: "exam_2017_mysol"
author: "David Bj√∂relind"
date: "10/22/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
# Include packages here
library(bnlearn)
library(gRain)
library(HMM)

```

## 1. Graphical Models
```{r}

### a) ###
data("asia")
train = x
# Using HC to learn structure and parameters
network = hc(asia, restart = 10)
plot(network)
parameters = bn.fit(network, asia) # Conditional parameters for all nodes

grain = as.grain(parameters) # Conditional probabilities, full compared to network (bn.fit) Moralize and triangulate
structure = compile(grain) # creating junction tree, separators & residuals. Potentials for the cliques
# Want to test D _|_ X | E

evi = setEvidence(structure, nodes = c("X", "E"), states = c("no", "no")) 
dist1 = querygrain(evi, nodes = c("D"))
evi = setEvidence(structure, nodes = c("X", "E"), states = c("no", "yes")) 
dist2 = querygrain(evi, nodes = c("D"))
evi = setEvidence(structure, nodes = c("X", "E"), states = c("yes", "no")) 
dist3 = querygrain(evi, nodes = c("D"))
evi = setEvidence(structure, nodes = c("X", "E"), states = c("yes", "yes")) 
dist4 = querygrain(evi, nodes = c("D"))

### b) ###
# Essential DAGs
network = hc(asia, restart = 10)
plot(network)
a = cpdag(network)
plot(a)

# Generating grapgs
graphs = random.graph(c("A","B","C","D","E"), num = 50000)
graphs = unique(graphs)
cpdags = lapply(graphs, cpdag)

# Comparing graphs
count = 0
for (i in 1:length(cpdags)){
  if(all.equal(graphs[[i]], cpdags[[i]]) == TRUE){
    count = count+1
  }
}

# Ratio
ratio = count/length(graphs)

### Essential DAG: ###
# Not Markov equivalent to any other DAG. Aka the union of all Markov equivalent DAGs

### Markov equivalent: ###
# Have the same skeleton
# Having the same colliders
```

## 2. Hidden Markov Models
```{r}
## Part a)
# Building a Hidden Markov Model
state = rep(1:100) # Actual number of states that the robot can be in (Hidden) Z nodes
probs = rep(1/100, 100)
symbols = 1:2 # States that we can observe (Not hidden) ### door or not? X nodes

funcmod = function(i){
  if(i == 100){
    return(i)
  } else if(i<=0){
    return(i+100)
  }else{
    return(i%%100)
  }
}

# If robot is in sector i:
transP = matrix(0, nrow = length(state), ncol = length(state))
for(i in 1:length(state)){
  transP[i,i] = 0.1
  transP[i, funcmod(i+1)] = 0.9
}

emissionP = matrix(.1, length(state), length(symbols))
emissionP[,2] = 0.9
emissionP[c(10,11,12,20,21,22,30,21,32),] = c(0.9,0.1)

# Initializing hidden markov model
robot = initHMM(States = state, Symbols = symbols, startProbs = probs, transProbs = transP, emissionProbs = emissionP)

## Part b)
which.maxima = function(x){
  return(which(x==max(x)))
}

obs = c(1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2) # Robot at 3rd door and then moves into nothingness
post = posterior(robot, obs)

apply(post, 2, which.maxima)
```

## 3. Reinforcement Learning
```{r}
# Covariance function
SquaredExpKernel <- function(x1,x2,sigmaF=1,l=3){
  n1 <- length(x1)
  n2 <- length(x2)
  K <- matrix(NA,n1,n2)
  for (i in 1:n2){
    K[,i] <- sigmaF^2*exp(-0.5*( (x1-x2[i])/l)^2 )
  }
  return(K)
}

sigmaF = sqrt(1)
ell = c(0.2,1)
xGrid = seq(-1,1, by=0.1)
```

## 4. Gaussian Processes
```{r}
load("GPdata.RData")


```

## Another chunk
```{r}

```